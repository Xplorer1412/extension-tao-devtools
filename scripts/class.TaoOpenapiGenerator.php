<?php

use oat\oatbox\service\ServiceManager;
use oat\taoDevTools\helper\OpenapiScanner;

/**
 * Generate/update openapi defenitions from annotations for all extension
 *
 * @noinspection AutoloadingIssuesInspection
 * @access public
 * @author Jerome Bogaerts, <jerome.bogaerts@tudor.lu>
 * @package tao
 * @subpackage scripts
 */
class taoDevTools_scripts_TaoOpenapiGenerator extends tao_scripts_Runner
{
    const PARAM_OUT_FILE = 'out-file';
    const OUT_FILE_DEFAULT = 'doc/swagger.autogenerated.json';
    const PARAM_INCLUDE_DEPS_SCHEMAS = 'include-deps-schemas';
    const PARAM_INCLUDE_DEPS_SCHEMAS_DEFAULT = true;

    /**
     * @var string
     */
    protected $paramOutFilePath;

    /**
     * @var bool
     */
    protected $includeDepsSchemas;

    /**
     * @var \common_ext_ExtensionsManager
     */
    protected $extensionManager;

    /**
     * @var \OpenApi\Annotations\Schema[] $schemasCache with string keys
     */
    protected $schemasCache = [];

    /**
     * @var string[] key: schema name, value: extension id
     */
    protected $missedSchemaRefs = [];

    /**
     * @var OpenapiScanner\ScanResult[] with string keys (extId)
     */
    protected $secondRound = [];

    /**
     * @var string[]
     */
    private $savedFiles = [];

    /**
     * @param array inputFormat
     * @param array options
     */
    public function __construct($inputFormat = [], $options = [])
    {
        if (count($inputFormat) === 0) {
            $inputFormat = [
                'parameters' => [
                    [
                        'name' => self::PARAM_OUT_FILE,
                        'type' => 'string',
                        'shortcut' => 'o',
                        'description' =>
                            'Path to output file relative to extension dir. ' . self::OUT_FILE_DEFAULT . ' by default'
                    ],
                    [
                        'name' => self::PARAM_INCLUDE_DEPS_SCHEMAS,
                        'type' => 'boolean',
                        'shortcut' => 'd',
                        'description' =>
                            'Include schemas from dependencies to out json. ' .
                            self::PARAM_INCLUDE_DEPS_SCHEMAS_DEFAULT. ' by default'
                    ]
                ]
            ];
        }
        
        parent::__construct($inputFormat, $options);
    }

    protected function preRun()
    {
        $this->extensionManager = ServiceManager::getServiceManager()->get(\common_ext_ExtensionsManager::SERVICE_ID);

        $this->paramOutFilePath = isset($this->parameters[self::PARAM_OUT_FILE])
            ? $this->parameters[self::PARAM_OUT_FILE]
            : self::OUT_FILE_DEFAULT;

        $this->includeDepsSchemas = isset($this->parameters[self::PARAM_INCLUDE_DEPS_SCHEMAS])
            ? $this->parameters[self::PARAM_INCLUDE_DEPS_SCHEMAS]
            : self::PARAM_INCLUDE_DEPS_SCHEMAS_DEFAULT;
    }


    /**
     * @return mixed
     * @throws Exception
     */
    public function run()
    {
        $this->runFirstRound();

        if ($this->includeDepsSchemas) {
            $this->runSecondRound();
        }

        $this->printStats();
        return null;
    }

    /**
     * @throws Exception
     */
    protected function runFirstRound() {
        $extIds = $this->getExtensionsId(true, true);

        // First round, save files for extension without dependencies and collecting schemas
        foreach ($extIds as $extId) {
            $this->out("Scanning $extId...");
            $extPath = self::getExtensionPath($extId);
            $outFilePath = $this->getOutFilePath($extPath);

            $scanRes = OpenapiScanner::scan($extPath);
            if ($scanRes->hasParsedAnnotations()) {
                $this->addSchemasToCache($scanRes->getSchemas());
                if ($scanRes->hasMissedRefs()) {
                    $missedCount = count($scanRes->missedSchemaRefs);
                    if ($this->includeDepsSchemas) {
                        $this->out("        Has $missedCount missed refs, postponed for second round");
                    }
                    $this->secondRound[$extId] = $scanRes;
                    foreach ($scanRes->missedSchemaRefs as $missedSchemaRef => $bool) {
                        $this->missedSchemaRefs[$missedSchemaRef] = $extId;
                        if (!$this->includeDepsSchemas) {
                            $this->out("        [ERR] $missedSchemaRef is missed!");
                        }
                    }
                }
                else if ($scanRes->hasPathItems()) {
                    $scanRes->analysis->openapi->saveAs($outFilePath, 'json');
                    $this->savedFiles[] = $outFilePath;
                    $this->out("        {$this->paramOutFilePath} saved");
                }
                else {
                    $this->out('        path items not found');
                }
            }
            else {
                $this->out('        annotations not found');
            }
        }
    }

    /**
     * @throws Exception
     */
    protected function runSecondRound() {
        $this->out('---------');
        $this->out('Second round (search for schemes in external extensions):');
        foreach ($this->secondRound as $extId => $scanRes) {
            $this->out("Processing $extId...");
            $outFilePath = $this->getOutFilePath(self::getExtensionPath($extId));
            $this->addMissedSchemas($scanRes, []);
            $scanRes->analysis->openapi->saveAs($outFilePath, 'json');
            $this->savedFiles[] = $outFilePath;
            $this->out("        {$this->paramOutFilePath} saved");
        }
    }

    protected function printStats() {
        $this->out('------------');
        $this->out('Saved files:');
        foreach ($this->savedFiles as $savedFile) {
            $this->out($savedFile);
        }

        if (count($this->missedSchemaRefs) > 0) {
            $this->out('------------');
            $this->out('Missed refs:');
            foreach ($this->missedSchemaRefs as $missedRef => $extId) {
                $this->out("$missedRef in $extId");
            }
            $this->out('');
            $this->out('WITH ERRORS');
        }
        else {
            $this->out('');
            $this->out('SUCCESS');
        }
    }

    /**
     * @param bool $installed
     * @param bool $available
     * @return string[]
     */
    protected function getExtensionsId($installed, $available) {
        $ids = [];

        if ($installed) {
            $ids = $this->extensionManager->getInstalledExtensionsIds();
        }

        if ($available) {
            $extractId = function ($ext) {
                /** @var \common_ext_Extension $ext */
                return $ext->getId();
            };
            $ids = array_merge($ids, array_map($extractId, $this->extensionManager->getAvailableExtensions()));
        }

        return $ids;
    }

    /**
     * @param string $extId
     * @return string
     */
    protected static function getExtensionPath($extId) {
        return rtrim(ROOT_PATH, DIRECTORY_SEPARATOR) .
            DIRECTORY_SEPARATOR .
            $extId;
    }

    protected function getOutFilePath($extDirPath) {
        return $extDirPath . DIRECTORY_SEPARATOR . $this->paramOutFilePath;
    }

    /**
     * @param string $extId
     * @return bool[] string keys are extId
     * @throws common_ext_ExtensionException
     */
    protected function getExtensionDependencies($extId)
    {
        $ext = $this->extensionManager->getExtensionById($extId);
        return array_map(function () { return true; }, $ext->getDependencies());
    }

    /**
     * @param \OpenApi\Annotations\Schema[] $schemas
     */
    protected function addSchemasToCache($schemas) {
        foreach ($schemas as $schema) {
            $this->schemasCache[$schema->schema] = $schema;
        }
    }

    /**
     * @param OpenapiScanner\ScanResult $scanRes
     * @param string[] $knownMissingRefs
     * @return OpenapiScanner\ScanResult
     */
    protected function addMissedSchemas(OpenapiScanner\ScanResult $scanRes, $knownMissingRefs) {
        $schemasToAdd = [];

        $found = false;
        $newMissedRefs = array_diff_assoc($scanRes->missedSchemaRefs, $knownMissingRefs);

        foreach ($newMissedRefs as $missedSchemaRef => $bool) {
            if (isset($this->schemasCache[$missedSchemaRef])) {
                $schemasToAdd[] = $this->schemasCache[$missedSchemaRef];
                $found = true;
                unset($this->missedSchemaRefs[$missedSchemaRef]);
            }
            else {
                $knownMissingRefs[$missedSchemaRef] = true;
                $this->out("        [ERR] $missedSchemaRef is missed!");
            }
        }

        if (!$found) {
            return $scanRes;
        }

        $scanRes = OpenapiScanner::addSchemasToAnalysis($scanRes->analysis, $schemasToAdd);
        if (\count($scanRes->missedSchemaRefs) > 0) {
            $scanRes = $this->addMissedSchemas($scanRes, $knownMissingRefs);
        }

        return $scanRes;
    }
}